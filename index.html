  <html>
  <head>
    <link rel='stylesheet' href='spectrum.css' />
    <link rel='stylesheet' href='style.css' />
  </head>
  <body>
    <div class="row">
      <div id="kdtree"></div>
    </div>
    <div class="row" id="left">
      <div class="heading">Pick a color:</div>
      <input type="text" id="picker"></input>
      <br />
    </div>
    
    <div id="results">Results:
      <ul></ul>
    </div>
    
    <script src="//code.jquery.com/jquery-2.2.4.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js"></script>
    <script src="vendor/kdTree.js"></script>
    <script src="xkcd_common_colors.json"></script>
    <script src="spectrum.js"></script>
    <script>
      var tree;
      var data;
      var nearest = [];
      // Pretty good color distance from
      // http://www.compuphase.com/cmetric.htm
      function colorDistance(a, b) {
        var dr = a.red - b.red;
        var dg = a.green - b.green;
        // var db = a.blue - b.blue;
        var redMean = (a.red + b.red)/2;
        return (2+redMean/256)*dr*dr + 4*dg*dg;// + (2 + (255 - redMean)/256)*db*db;
      }

      function setRGBfromHex (hex_color) {
        var color = new tinycolor(hex_color.hex).toRgb();
        hex_color.red = color.r;
        hex_color.green = color.g;
        hex_color.blue = color.b;
      }

      $(function(){ // on document load

        for(var i=0; i<colors.length; i++) {
          setRGBfromHex(colors[i]);
        }
        

        $("#picker").spectrum({
          flat: true,
          showInput: true,
          preferredFormat: "hex",
          move: update
        });

        var colorSubset = colors;
            // console.log(colorSubset);
        tree = new kdTree(colorSubset, colorDistance, ["red", "green"]); //,"blue"]);
        data = tree.pointsBFS();

        // D3

        var margin = {top: 0, right: 0, bottom: 0, left: 0},
            width  = 400 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom;
        var pointRadius = 3;

        var x = d3.scale.linear()
                .range([0, width])
                .domain([-pointRadius, 255 + pointRadius]).nice();

        var y = d3.scale.linear()
                .range([height, 0])
                .domain([-pointRadius, 255 + pointRadius]).nice();

        var svg = d3.select("#kdtree").append("svg")
                  .attr("width", width + margin.left + margin.right)
                  .attr("height", height + margin.top + margin.bottom)
                  .append("g")
                  .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        var linesG = svg.append("g")
                    .attr("class", "lines");

        var pointsG = svg.append("g")
                     .attr("class", "points");

        var tooltip = d3.select("body")
                      .append("div")
                      .attr("class", "tooltip")
                      .style("position", "absolute")
                      .style("z-index", "10")
                      .style("visibility", "hidden")

        var swatch = tooltip.append("div")
                      .attr("class", "tooltip-swatch");

        var label = tooltip.append("p")
                    .text("a simple tooltip"); 

        var i = 1;
        function drawIteratively(){
            drawDataSubset(data.slice(0, i));
            if (i < colors.length) {
              i++;
              setTimeout(drawIteratively, colors.length - i * 50);
            }
        }
        // drawIteratively();
        drawDataSubset(data);

        function drawDataSubset(dataSubset) {

          // linesG.selectAll("*").remove();
          // pointsG.selectAll("*").remove();

          var points = pointsG.selectAll(".point")
            .data(dataSubset, function(d){return d.hex})
          
          points.enter()
            .append("circle")
              .attr("class", "point")
              .attr("dimension", function(d) { return d.dimension;  })
              .attr("cx",      function(d) { return x(d.red);  })
              .attr("cy",      function(d) { return y(d.green); })
              .style("fill",   function(d) { return d3.rgb(d.hex); })
              .on("mouseover", function(d) { swatch.style("background-color", d3.rgb(d.hex)); tooltip.style("visibility", "visible"); label.text(d.title);} )
              .on("mousemove", function(d) { return tooltip.style("top", (event.pageY-10)+"px").style("left",(event.pageX+10)+"px");})
              .on("mouseout",  function(d) { return tooltip.style("visibility", "hidden");} );
          //   .style("opacity", 0)
          // .transition()
          //   .duration(400)
          //   .style('opacity', 1)
          // .exit.remove();
          points
            // .transition()
            .attr("r", function(d) { 
              var contained = false;
              for (var i = 0; i < nearest.length; i++) {
                var near_node = nearest[i][0]
                // console.log(near_node);
                if (near_node.hex == d.hex) {
                  contained = true;
                }
              };
              return contained ? pointRadius * 3 : pointRadius;
            });

          linesG.selectAll(".point-line")
            .data(dataSubset, function(d){return d.hex})
          .enter()
          .append("line")
            .attr("class", "point-line")
            .attr("x1",    function(d) { return x(d.x1); })
            .attr("y1",    function(d) { return y(d.y1); })
            .attr("x2",    function(d) { return x(d.x2); })
            .attr("y2",    function(d) { return y(d.y2); })
            .attr("stroke",function(d) {
              switch(d.dimension) {
                case 0: return d3.rgb(d.red, 0, 0);
                case 1: return d3.rgb(0, d.green, 0);
                // case 2: return "green";
              }
            })
            // .attr("stroke-width", function(d) { return w(d.depth); })
            .attr("stroke-width", 1)
            .style("opacity", 0.8)
          // .transition()
          //   .duration(400)
          //   .style('opacity', 0.4)
          // .exit.remove();
        }

        function drawSearchColor(searchColor) {

          var point = pointsG.selectAll(".searchpoint")
            .data([searchColor], function(d){return d.title});

          point.enter()
            .append("circle")
              .attr("class", "searchpoint")
              .attr("r", 10)
              .attr("stroke-width", 3);

          point
            .attr("cx",        function(d) { return x(d.red);      })
            .attr("cy",        function(d) { return y(d.green);    })
            .style("fill", "black")
            .style("stroke",     function(d) { return d3.rgb(d.hex); });
        }

        function update(color) {
          $("#picked").css('background', color.toHex());
          var rgb = color.toRgb();
          var search = {red: rgb.r, green: rgb.g, blue: rgb.b};
          var object = search;
          object.title = "search";
          object.hex = "#" + color.toHex();
          setRGBfromHex(object);
          nearest = tree.nearest(search, 3);
          nearest.sort(function(a,b){return a[1] - b[1]});
          drawSearchColor(object); // move search circle
          drawDataSubset(data); // update search highlight


          var $list = $("#results ul");
          $list.html("");
          for(var i=0; i<nearest.length; i++) {
            var c = nearest[i][0];

            var $box = $("<div>")
              .css('background', c.hex)
              .css('display', 'inline-block')
              .css('margin-right', '10px')
              .height('30px')
              .width('30px');
            var $line = $("<li>").append($box).append(c.title);
            $list.append($line);
          }
      }

      });
    </script>
  </body>
</html>
